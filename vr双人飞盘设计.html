<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åŒäººARéœ“è™¹å°„å‡» - æé€Ÿç«æŠ€ç‰ˆ</title>
    <!-- å¼•å…¥ MediaPipe åº“ -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #050505;
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            color: white;
            user-select: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* æ‘„åƒå¤´è§†é¢‘å±‚ */
        #input_video {
            position: absolute;
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* é•œåƒç¿»è½¬ */
            opacity: 0.2; /* ä¿æŒä½é€æ˜åº¦ */
            filter: grayscale(100%) contrast(1.2); 
            z-index: 1;
        }

        /* æ¸¸æˆç”»å¸ƒå±‚ */
        #output_canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            z-index: 2;
        }

        /* UI ç•Œé¢ */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 3;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            padding: 30px;
            font-size: 28px;
            font-weight: 800;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .score-box {
            background: rgba(0, 0, 0, 0.6);
            padding: 15px 30px;
            border-radius: 4px;
            border-bottom: 4px solid;
            backdrop-filter: blur(5px);
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        
        .score-pulse {
            transform: scale(1.2);
        }
        
        .score-deduct {
            color: #ff3333 !important;
            animation: shake 0.5s;
        }

        @keyframes shake {
            0% { transform: translate(1px, 1px) rotate(0deg); }
            10% { transform: translate(-1px, -2px) rotate(-1deg); }
            20% { transform: translate(-3px, 0px) rotate(1deg); }
            30% { transform: translate(3px, 2px) rotate(0deg); }
            40% { transform: translate(1px, -1px) rotate(1deg); }
            50% { transform: translate(-1px, 2px) rotate(-1deg); }
            60% { transform: translate(-3px, 1px) rotate(0deg); }
            70% { transform: translate(3px, 1px) rotate(-1deg); }
            80% { transform: translate(-1px, -1px) rotate(1deg); }
            90% { transform: translate(1px, 2px) rotate(0deg); }
            100% { transform: translate(1px, -2px) rotate(-1deg); }
        }

        #p1-score { color: #ff0055; border-color: #ff0055; text-shadow: 0 0 10px #ff0055; }
        #p2-score { color: #00ccff; border-color: #00ccff; text-shadow: 0 0 10px #00ccff; }

        .center-message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(10, 10, 10, 0.9);
            padding: 40px 60px;
            border-radius: 20px;
            pointer-events: auto;
            border: 1px solid rgba(255,255,255,0.1);
            box-shadow: 0 0 50px rgba(0,255,255,0.1);
            backdrop-filter: blur(10px);
            max-width: 80%;
        }

        h1 { margin: 0 0 20px 0; color: #fff; font-size: 3em; text-shadow: 0 0 20px rgba(255,255,255,0.5); }
        h2 { color: #ffeb3b; font-size: 2em; margin: 10px 0; }
        p { margin: 10px 0; font-size: 1.2em; color: #ccc; }
        
        .instruction-grid {
            display: flex;
            gap: 20px;
            margin: 20px 0;
            justify-content: center;
            flex-wrap: wrap;
        }
        .instruction-card {
            background: rgba(255,255,255,0.05);
            padding: 15px;
            border-radius: 10px;
            border: 1px solid rgba(255,255,255,0.1);
            min-width: 150px;
        }

        .strategy-tip {
            margin-top: 15px;
            font-size: 0.9em;
            color: #ffeb3b;
            background: rgba(255, 235, 59, 0.1);
            padding: 10px;
            border-radius: 5px;
        }

        .loading {
            color: #00ccff;
            font-weight: bold;
            animation: pulse 1s infinite;
            margin-top: 20px;
        }

        @keyframes pulse {
            0% { opacity: 0.5; }
            50% { opacity: 1; }
            100% { opacity: 0.5; }
        }

        button.start-btn {
            background: linear-gradient(90deg, #ff0055, #00ccff);
            border: none;
            padding: 20px 60px;
            color: white;
            font-size: 24px;
            border-radius: 4px;
            cursor: pointer;
            margin-top: 30px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 2px;
            box-shadow: 0 0 30px rgba(255, 0, 85, 0.4);
            transition: all 0.3s;
            pointer-events: all;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
        }

        button.start-btn:hover {
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 0 50px rgba(0, 204, 255, 0.6);
        }

        .hidden { display: none !important; }

        #status-bar {
            position: absolute;
            bottom: 10px;
            left: 10px;
            font-size: 12px;
            color: #555;
            z-index: 10;
        }

        #divider {
            position: absolute;
            left: 50%;
            top: 20%;
            bottom: 20%;
            width: 2px;
            background: linear-gradient(to bottom, transparent, rgba(255,255,255,0.1), transparent);
            z-index: 2;
            pointer-events: none;
        }
    </style>
</head>
<body>

<div id="game-container">
    <video id="input_video" playsinline></video>
    <canvas id="output_canvas"></canvas>
    <div id="divider"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="p1-score" class="score-box">P1 (å·¦): 0</div>
            <div id="p2-score" class="score-box">P2 (å³): 0</div>
        </div>

        <div id="start-screen" class="center-message">
            <h1>HYPER NEON AR</h1>
            
            <div class="instruction-grid">
                <div class="instruction-card" style="border-left: 4px solid #ff0055;">
                    <div style="color:#ff0055; font-weight:bold;">ç©å®¶ 1 (çº¢)</div>
                    <div>æ”»å‡»çº¢è‰²ç›®æ ‡åŒå€åˆ†</div>
                </div>
                <div class="instruction-card" style="border-left: 4px solid #00ccff;">
                    <div style="color:#00ccff; font-weight:bold;">ç©å®¶ 2 (è“)</div>
                    <div>æ”»å‡»è“è‰²ç›®æ ‡åŒå€åˆ†</div>
                </div>
            </div>

            <div class="strategy-tip">
                âš ï¸ <b>è­¦æƒ•ï¼š</b> é»‘è‰²å°–åˆºæ˜¯ç‚¸å¼¹ (æ‰£åˆ†!)<br>
                ğŸ‘‘ <b>åˆä½œï¼š</b> é‡‘è‰²é£ç›˜éœ€è¦æ‰“ 2 æ¬¡
            </div>

            <p style="margin-top: 20px;">ğŸ–ï¸ <b>é£ŸæŒ‡</b>ç„å‡† &nbsp; | &nbsp; ğŸ‘Œ <b>æåˆ</b>å°„å‡»</p>
            
            <div id="loading-text" class="loading">æ­£åœ¨åŠ è½½ Lite æ¨¡å‹ (æ€§èƒ½ä¼˜åŒ–ç‰ˆ)...</div>
            <button id="start-btn" class="start-btn hidden" onclick="startGame()">æé€Ÿå¯åŠ¨</button>
        </div>
        
        <div id="game-over-screen" class="center-message hidden">
            <h1>MISSION COMPLETE</h1>
            <h2 id="winner-text"></h2>
            <p id="final-scores" style="font-size: 1.5em; color: white;"></p>
            <button class="start-btn" onclick="resetGame()">å†æ¬¡æŒ‘æˆ˜</button>
        </div>
    </div>
    
    <div id="status-bar">Initialize system...</div>
</div>

<script>
    // --- æ¸¸æˆé«˜çº§é…ç½® ---
    const CONFIG = {
        frisbeeSpawnRate: 35, // é¢‘ç‡å¤§å¹…åŠ å¿« (åŸ45)
        maxFrisbees: 25,
        gravity: 0.18, // é‡åŠ›å¢åŠ 
        shootCooldown: 10, // å°„é€ŸåŠ å¿«
        pinchThreshold: 0.06,
        gameDuration: 90,
        bombChance: 0.15, // 15% æ¦‚ç‡ç”Ÿæˆç‚¸å¼¹
        goldChance: 0.1,  // 10% æ¦‚ç‡ç”Ÿæˆé»„é‡‘é£ç›˜
        colors: {
            p1: '#ff0055', // Red/Pink
            p2: '#00ccff', // Cyan/Blue
            bomb: '#222222',
            gold: '#ffd700',
            // åŒºåˆ†P1 P2 åå¥½çš„é¢œè‰²æ± 
            p1_targets: ['#ff0055', '#ff4d4d', '#ff00aa'],
            p2_targets: ['#00ccff', '#4d4dff', '#00ffff'],
            neutral: ['#ccff00', '#ffffff']
        }
    };

    const videoElement = document.getElementById('input_video');
    const canvasElement = document.getElementById('output_canvas');
    const canvasCtx = canvasElement.getContext('2d');
    const statusBar = document.getElementById('status-bar');
    
    let isGameRunning = false;
    let gameLoopId;
    let frameCount = 0;
    let bgmInterval;
    
    const players = [
        { id: 0, color: CONFIG.colors.p1, score: 0, x: 0.25, y: 0.5, active: false, cooldown: 0, trigger: false, hitScale: 1 },
        { id: 1, color: CONFIG.colors.p2, score: 0, x: 0.75, y: 0.5, active: false, cooldown: 0, trigger: false, hitScale: 1 }
    ];

    let frisbees = [];
    let bullets = [];
    let particles = [];
    let floatingTexts = [];

    // --- éŸ³é¢‘å¼•æ“ (Synth) ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    
    const soundEngine = {
        playTone: (freq, type, duration, vol = 0.1) => {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
            gain.gain.setValueAtTime(vol, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(audioCtx.currentTime + duration);
        },
        shoot: () => {
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(800, t);
            osc.frequency.exponentialRampToValueAtTime(100, t + 0.1);
            gain.gain.setValueAtTime(0.08, t); // é™ä½ä¸€ç‚¹éŸ³é‡é¿å…åµé—¹
            gain.gain.exponentialRampToValueAtTime(0.01, t + 0.1);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(t + 0.15);
        },
        explosion: (isBig = false) => {
            const bufferSize = audioCtx.sampleRate * (isBig ? 0.5 : 0.3);
            const buffer = audioCtx.createBuffer(1, bufferSize, audioCtx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < bufferSize; i++) data[i] = Math.random() * 2 - 1;
            const noise = audioCtx.createBufferSource();
            noise.buffer = buffer;
            const gain = audioCtx.createGain();
            gain.gain.setValueAtTime(isBig ? 0.3 : 0.15, audioCtx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + (isBig ? 0.5 : 0.3));
            noise.connect(gain);
            gain.connect(audioCtx.destination);
            noise.start();
        },
        error: () => {
            // ç‚¸å¼¹éŸ³æ•ˆ
            soundEngine.playTone(150, 'sawtooth', 0.3, 0.3);
            setTimeout(() => soundEngine.playTone(100, 'sawtooth', 0.3, 0.3), 100);
        },
        bgmBeat: () => {
            // ç®€å•çš„120BPM èŠ‚å¥
            soundEngine.playTone(80, 'sine', 0.1, 0.2);
            setTimeout(() => soundEngine.playTone(40, 'square', 0.05, 0.05), 250);
        }
    };

    function startBGM() {
        if (bgmInterval) clearInterval(bgmInterval);
        bgmInterval = setInterval(soundEngine.bgmBeat, 500); 
    }
    function stopBGM() {
        if (bgmInterval) clearInterval(bgmInterval);
    }

    // --- å®ä½“ç±» ---

    class Frisbee {
        constructor() {
            this.radius = 20 + Math.random() * 20;
            this.x = Math.random() * canvasElement.width;
            this.y = canvasElement.height + this.radius;
            
            // ğŸš€ é€Ÿåº¦å¤§å¹…æå‡
            this.vx = (Math.random() - 0.5) * 16; 
            this.vy = -(Math.random() * 8 + 10); // åŸºç¡€å‘ä¸Šé€Ÿåº¦å¢åŠ 
            
            this.angle = 0;
            this.spinSpeed = (Math.random() - 0.5) * 0.5;
            this.markedForDeletion = false;

            // ç­–ç•¥ç±»å‹ç”Ÿæˆ
            const rand = Math.random();
            if (rand < CONFIG.bombChance) {
                this.type = 'bomb';
                this.color = CONFIG.colors.bomb;
                this.hp = 1;
            } else if (rand < CONFIG.bombChance + CONFIG.goldChance) {
                this.type = 'gold';
                this.color = CONFIG.colors.gold;
                this.hp = 2; // éœ€è¦æ‰“ä¸¤æ¬¡
                this.radius += 5; // ç¨å¾®å¤§ä¸€ç‚¹
            } else {
                this.type = 'normal';
                this.hp = 1;
                // éšæœºåˆ†é…åå¥½è‰²æˆ–ä¸­æ€§è‰²
                const colorRoll = Math.random();
                if (colorRoll < 0.4) {
                    this.color = CONFIG.colors.p1_targets[Math.floor(Math.random() * CONFIG.colors.p1_targets.length)];
                } else if (colorRoll < 0.8) {
                    this.color = CONFIG.colors.p2_targets[Math.floor(Math.random() * CONFIG.colors.p2_targets.length)];
                } else {
                    this.color = CONFIG.colors.neutral[Math.floor(Math.random() * CONFIG.colors.neutral.length)];
                }
            }
        }

        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.vy += CONFIG.gravity;
            this.angle += this.spinSpeed;
            if (this.y > canvasElement.height + 100 || this.x < -100 || this.x > canvasElement.width + 100) {
                this.markedForDeletion = true;
            }
        }

        draw(ctx) {
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.rotate(this.angle);
            
            // âš¡ æ€§èƒ½ä¼˜åŒ–: ç§»é™¤ shadowBlurï¼Œæ”¹ç”¨å åŠ ç»˜åˆ¶æ¨¡æ‹Ÿå‘å…‰
            // Bomb ç»˜åˆ¶ä¸ºå°–åˆº
            if (this.type === 'bomb') {
                ctx.fillStyle = '#111';
                ctx.strokeStyle = '#ff0000';
                ctx.lineWidth = 3;
                ctx.beginPath();
                const spikes = 8;
                for(let i=0; i<spikes*2; i++){
                    const r = (i%2 === 0) ? this.radius : this.radius/2;
                    const a = (Math.PI / spikes) * i;
                    ctx.lineTo(Math.cos(a)*r, Math.sin(a)*r);
                }
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
                
                // çº¢è‰²è­¦å‘Šæ ¸å¿ƒ
                ctx.fillStyle = `rgba(255, 0, 0, ${0.5 + Math.sin(frameCount*0.2)*0.5})`;
                ctx.beginPath();
                ctx.arc(0, 0, this.radius * 0.4, 0, Math.PI*2);
                ctx.fill();

            } else {
                // æ™®é€š & é»„é‡‘é£ç›˜
                ctx.fillStyle = this.color;
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = this.type === 'gold' ? 4 : 2;

                // ä¸»ä½“
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius, this.radius * 0.4, 0, 0, Math.PI * 2);
                ctx.fill(); // åŸºç¡€é¢œè‰²
                
                // "å‘å…‰"å±‚ - ç”¨åŠé€æ˜å†ç”»ä¸€æ¬¡ï¼Œæ¯” shadowBlur å¿«
                ctx.globalCompositeOperation = 'lighter';
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, this.radius * 1.2, this.radius * 0.5, 0, 0, Math.PI * 2);
                ctx.globalAlpha = 0.4;
                ctx.fill();
                
                ctx.globalCompositeOperation = 'source-over'; // æ¢å¤
                ctx.globalAlpha = 1.0;
                ctx.stroke();

                // é»„é‡‘é£ç›˜ç‰¹æ®Šæ ‡è®°
                if (this.type === 'gold') {
                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 16px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(this.hp > 1 ? "2" : "1", 0, 0);
                }
            }
            ctx.restore();
        }
    }

    class Particle {
        constructor(x, y, color) {
            this.x = x;
            this.y = y;
            this.color = color;
            this.size = Math.random() * 3 + 1; // ç¨å¾®å˜å°
            const angle = Math.random() * Math.PI * 2;
            const speed = Math.random() * 8 + 2;
            this.vx = Math.cos(angle) * speed;
            this.vy = Math.sin(angle) * speed;
            this.life = 1.0;
            this.decay = Math.random() * 0.05 + 0.05; // æ¶ˆå¤±å¾—æ›´å¿«ï¼Œæå‡æ€§èƒ½
        }
        update() {
            this.x += this.vx;
            this.y += this.vy;
            this.life -= this.decay;
        }
        draw(ctx) {
            ctx.save(); // Fix: ä¿å­˜ä¸Šä¸‹æ–‡ï¼Œé˜²æ­¢é€æ˜åº¦æ³„æ¼
            ctx.globalAlpha = this.life;
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore(); // Fix: æ¢å¤ä¸Šä¸‹æ–‡
        }
    }

    class FloatingText {
        constructor(x, y, text, color) {
            this.x = x;
            this.y = y;
            this.text = text;
            this.color = color;
            this.life = 1.0;
            this.vy = -3;
        }
        update() {
            this.y += this.vy;
            this.life -= 0.03;
        }
        draw(ctx) {
            ctx.save();
            ctx.globalAlpha = Math.max(0, this.life);
            ctx.fillStyle = this.color;
            ctx.font = 'bold 28px Arial';
            ctx.strokeStyle = 'black';
            ctx.lineWidth = 3;
            ctx.strokeText(this.text, this.x, this.y);
            ctx.fillText(this.text, this.x, this.y);
            ctx.restore();
        }
    }

    // --- MediaPipe é…ç½® (Liteæ¨¡å¼ä¼˜åŒ–) ---
    const hands = new Hands({locateFile: (file) => {
        return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
    }});

    hands.setOptions({
        maxNumHands: 2,
        modelComplexity: 0, // âš¡ 0 = Lite (æœ€å¿«), 1 = Full. åˆ‡æ¢åˆ° 0 è§£å†³å¡é¡¿
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5
    });

    hands.onResults(onResults);

    // é™ä½ä¸€ç‚¹ç‚¹åˆ†è¾¨ç‡æ¥æé«˜å¤„ç†é€Ÿåº¦ï¼Œä½†æ˜¾ç¤ºä¿æŒå…¨å±
    const camera = new Camera(videoElement, {
        onFrame: async () => {
            await hands.send({image: videoElement});
        },
        width: 1280,
        height: 720
    });

    // --- æ¸¸æˆé€»è¾‘ ---

    function onResults(results) {
        players[0].active = false;
        players[1].active = false;

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const detectedHands = results.multiHandLandmarks.map(landmarks => {
                // å®‰å…¨æ£€æŸ¥ï¼šç¡®ä¿å…³é”®ç‚¹å­˜åœ¨
                const indexTip = landmarks[8];
                const thumbTip = landmarks[4];

                // å¦‚æœå…³é”®ç‚¹ç¼ºå¤±ï¼Œè·³è¿‡æ­¤æ‰‹
                if (!indexTip || !thumbTip) {
                    return null; 
                }

                // åæ ‡è½¬æ¢
                const screenX = (1 - indexTip.x); 
                const distance = Math.sqrt(
                    Math.pow(indexTip.x - thumbTip.x, 2) + 
                    Math.pow(indexTip.y - thumbTip.y, 2)
                );
                return { screenX, screenY: indexTip.y, pinchDist: distance };
            }).filter(hand => hand !== null); // è¿‡æ»¤æ‰æ— æ•ˆæ•°æ®

            // åŒºåŸŸåˆ†é…
            detectedHands.forEach(hand => {
                let playerIndex = hand.screenX < 0.5 ? 0 : 1;
                const p = players[playerIndex];
                p.active = true;
                
                // åæ ‡å¹³æ»‘
                p.x = p.x + (hand.screenX * canvasElement.width - p.x) * 0.5;
                p.y = p.y + (hand.screenY * canvasElement.height - p.y) * 0.5;

                // å°„å‡»è§¦å‘
                if (hand.pinchDist < CONFIG.pinchThreshold) {
                    if (!p.trigger && p.cooldown <= 0) {
                        p.trigger = true;
                        shoot(p);
                    }
                } else {
                    p.trigger = false;
                }
            });
        }
    }

    function shoot(player) {
        if (!isGameRunning) return;
        soundEngine.shoot();
        player.cooldown = CONFIG.shootCooldown;
        player.hitScale = 1.3;
        
        // è§†è§‰å…‰æŸ
        bullets.push({
            x: player.x,
            y: player.y,
            color: player.color,
            life: 6
        });

        // ç¢°æ’æ£€æµ‹
        for (let i = frisbees.length - 1; i >= 0; i--) {
            const f = frisbees[i];
            const dx = f.x - player.x;
            const dy = f.y - player.y;
            const dist = Math.sqrt(dx*dx + dy*dy);

            // ç¨å¾®å®½å®¹ä¸€ç‚¹çš„åˆ¤å®š
            if (dist < f.radius + 25) {
                handleHit(f, i, player);
                break; // ä¸€æªä¸€ä¸ª
            }
        }
    }

    function handleHit(frisbee, index, player) {
        // ç‚¸å¼¹é€»è¾‘
        if (frisbee.type === 'bomb') {
            soundEngine.error();
            frisbees.splice(index, 1);
            player.score -= 500; // ä¸¥å‰æƒ©ç½š
            floatingTexts.push(new FloatingText(frisbee.x, frisbee.y, "-500", "#ff0000"));
            triggerScoreShake(player.id);
            // ç‚¸å¼¹ç‰¹æ•ˆ
            for (let k = 0; k < 30; k++) {
                particles.push(new Particle(frisbee.x, frisbee.y, "#ff0000"));
            }
            return;
        }

        // é»„é‡‘é£ç›˜ HP é€»è¾‘
        if (frisbee.type === 'gold' && frisbee.hp > 1) {
            frisbee.hp--;
            soundEngine.playTone(400, 'sine', 0.1); // å‡»ä¸­è£…ç”²éŸ³æ•ˆ
            // äº§ç”Ÿå°ç«èŠ±
            for (let k = 0; k < 5; k++) {
                particles.push(new Particle(frisbee.x, frisbee.y, "#ffff00"));
            }
            return; // è¿˜æ²¡æ­»
        }

        // å‡»æ¯é€»è¾‘
        soundEngine.explosion(frisbee.type === 'gold');
        frisbees.splice(index, 1);
        
        // åˆ†æ•°è®¡ç®—ç­–ç•¥
        let score = 100;
        let text = "+100";
        
        if (frisbee.type === 'gold') {
            score = 500;
            text = "GOLD +500";
        } else {
            // é¢œè‰²åŠ æˆ
            // P1(Red) hit Red-ish target
            if (player.id === 0 && CONFIG.colors.p1_targets.includes(frisbee.color)) {
                score = 200;
                text = "MATCH +200";
            }
            // P2(Blue) hit Blue-ish target
            else if (player.id === 1 && CONFIG.colors.p2_targets.includes(frisbee.color)) {
                score = 200;
                text = "MATCH +200";
            }
        }

        player.score += score;
        floatingTexts.push(new FloatingText(frisbee.x, frisbee.y, text, player.color));
        updateScoreBoard();

        // çˆ†ç‚¸ç²’å­
        const pCount = frisbee.type === 'gold' ? 30 : 15;
        for (let k = 0; k < pCount; k++) {
            particles.push(new Particle(frisbee.x, frisbee.y, frisbee.color));
        }
    }

    function triggerScoreShake(playerId) {
        const el = document.getElementById(playerId === 0 ? 'p1-score' : 'p2-score');
        el.classList.add('score-deduct');
        setTimeout(() => el.classList.remove('score-deduct'), 500);
        updateScoreBoard();
    }

    function updateScoreBoard() {
        document.getElementById('p1-score').innerText = `P1: ${players[0].score}`;
        document.getElementById('p2-score').innerText = `P2: ${players[1].score}`;
    }

    function update() {
        if (!isGameRunning) return;
        frameCount++;

        if (frameCount % CONFIG.frisbeeSpawnRate === 0 && frisbees.length < CONFIG.maxFrisbees) {
            frisbees.push(new Frisbee());
        }

        players.forEach(p => {
            if (p.hitScale > 1) p.hitScale *= 0.9;
            if (p.cooldown > 0) p.cooldown--;
        });

        frisbees.forEach(f => f.update());
        frisbees = frisbees.filter(f => !f.markedForDeletion);

        particles.forEach(p => p.update());
        particles = particles.filter(p => p.life > 0);
        
        bullets.forEach(b => b.life--);
        bullets = bullets.filter(b => b.life > 0);

        floatingTexts.forEach(t => t.update());
        floatingTexts = floatingTexts.filter(t => t.life > 0);
    }

    function draw() {
        // Fix: å¼ºåˆ¶é‡ç½®é€æ˜åº¦ï¼Œç¡®ä¿æ¸…é™¤ç”»é¢æ—¶æ˜¯å®Œå…¨ä¸é€æ˜çš„é»‘è‰²
        canvasCtx.globalAlpha = 1.0; 
        canvasCtx.globalCompositeOperation = 'source-over';

        // æ€§èƒ½ä¼˜åŒ–ï¼šæ¸…é™¤ç”»å¸ƒæ”¹ç”¨ fillRect é»‘è‰²ï¼Œå¯ä»¥ä¿ç•™ä¸€ç‚¹æ‹–å½±ä½†è¦æ§åˆ¶å¥½é€æ˜åº¦
        canvasCtx.fillStyle = '#050505'; 
        canvasCtx.fillRect(0, 0, canvasElement.width, canvasElement.height);

        drawGrid();

        if (!isGameRunning) return;

        // ç²’å­å±‚ (ä½¿ç”¨ lighter æ··åˆï¼Œéå¸¸å¿«ä¸”æ•ˆæœå¥½)
        canvasCtx.globalCompositeOperation = 'lighter';
        particles.forEach(p => p.draw(canvasCtx));
        
        // å…‰æŸ
        bullets.forEach(b => {
            canvasCtx.beginPath();
            canvasCtx.strokeStyle = b.color;
            canvasCtx.lineWidth = 4;
            canvasCtx.moveTo(b.x, b.y);
            canvasCtx.lineTo(b.x, canvasElement.height); 
            canvasCtx.stroke();
            
            // å‘½ä¸­ç‚¹
            canvasCtx.beginPath();
            canvasCtx.arc(b.x, b.y, 15, 0, Math.PI*2);
            canvasCtx.fillStyle = 'rgba(255,255,255,0.8)';
            canvasCtx.fill();
        });
        
        canvasCtx.globalCompositeOperation = 'source-over'; // åˆ‡æ¢å›æ­£å¸¸ç»˜åˆ¶

        frisbees.forEach(f => f.draw(canvasCtx));
        floatingTexts.forEach(t => t.draw(canvasCtx));

        // å‡†æ˜Ÿ
        players.forEach(p => {
            if (p.active) {
                const size = 30 * p.hitScale;
                canvasCtx.save();
                canvasCtx.translate(p.x, p.y);
                
                // ç®€å•çš„å‡†æ˜Ÿ (ä¸ä½¿ç”¨ shadowBlur)
                canvasCtx.beginPath();
                canvasCtx.strokeStyle = p.color;
                canvasCtx.lineWidth = 3;
                const rot = frameCount * 0.15;
                canvasCtx.arc(0, 0, size, rot, rot + Math.PI * 1.5);
                canvasCtx.stroke();
                
                canvasCtx.fillStyle = p.trigger ? '#fff' : p.color;
                canvasCtx.beginPath();
                canvasCtx.arc(0, 0, 6, 0, Math.PI * 2);
                canvasCtx.fill();

                if (p.cooldown > 0) {
                   canvasCtx.beginPath();
                   canvasCtx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                   canvasCtx.lineWidth = 2;
                   canvasCtx.arc(0, 0, size + 8, 0, (Math.PI*2) * (p.cooldown / CONFIG.shootCooldown));
                   canvasCtx.stroke();
                }
                canvasCtx.restore();
            }
        });
    }

    function drawGrid() {
        canvasCtx.strokeStyle = 'rgba(0, 204, 255, 0.08)'; // ææ·¡
        canvasCtx.lineWidth = 1;
        const gridSize = 80; // ç½‘æ ¼å˜å¤§å‡å°‘ç»˜åˆ¶æ¬¡æ•°
        const offset = (frameCount * 1.5) % gridSize; // ç§»åŠ¨å˜å¿«
        
        canvasCtx.beginPath();
        for(let x=0; x <= canvasElement.width; x+=gridSize) {
            canvasCtx.moveTo(x, 0);
            canvasCtx.lineTo(x, canvasElement.height);
        }
        for(let y=offset; y <= canvasElement.height; y+=gridSize) {
            canvasCtx.moveTo(0, y);
            canvasCtx.lineTo(canvasElement.width, y);
        }
        canvasCtx.stroke();
    }

    function gameLoop() {
        update();
        draw();
        gameLoopId = requestAnimationFrame(gameLoop);
    }

    function resizeCanvas() {
        canvasElement.width = window.innerWidth;
        canvasElement.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    function startGame() {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        document.getElementById('start-screen').classList.add('hidden');
        document.getElementById('game-over-screen').classList.add('hidden');
        players.forEach(p => { p.score = 0; p.cooldown = 0; });
        frisbees = [];
        bullets = [];
        particles = [];
        floatingTexts = [];
        updateScoreBoard();
        isGameRunning = true;
        startBGM();
        gameLoop();
    }

    function resetGame() {
        document.getElementById('game-over-screen').classList.add('hidden');
        startGame();
    }

    function gameOver() {
        isGameRunning = false;
        cancelAnimationFrame(gameLoopId);
        stopBGM();
        
        let winnerText = "";
        let winnerColor = "#fff";
        
        if (players[0].score > players[1].score) {
            winnerText = "PLAYER 1 WINS";
            winnerColor = players[0].color;
        } else if (players[1].score > players[0].score) {
            winnerText = "PLAYER 2 WINS";
            winnerColor = players[1].color;
        } else {
            winnerText = "DRAW GAME";
        }

        const winEl = document.getElementById('winner-text');
        winEl.innerText = winnerText;
        winEl.style.color = winnerColor;
        winEl.style.textShadow = `0 0 20px ${winnerColor}`;

        document.getElementById('final-scores').innerText = 
            `P1: ${players[0].score}  |  P2: ${players[1].score}`;
        document.getElementById('game-over-screen').classList.remove('hidden');
    }

    statusBar.innerText = "System Initializing...";
    
    function checkLibraryLoaded() {
        if (typeof Hands !== 'undefined' && typeof Camera !== 'undefined') {
            document.getElementById('loading-text').classList.add('hidden');
            document.getElementById('start-btn').classList.remove('hidden');
            statusBar.innerText = "Ready. Lite Model Loaded.";
            
            camera.start().then(() => {
                statusBar.innerText = "Camera Active.";
            }).catch(err => {
                console.error(err);
                alert("Camera Access Denied.");
            });
        } else {
            setTimeout(checkLibraryLoaded, 500);
        }
    }

    checkLibraryLoaded();

</script>
</body>
</html>